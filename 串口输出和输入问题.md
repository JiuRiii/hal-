# STM32 HAL库学习笔记：串口通信与数据错位修复

## 1. 串口输出 (printf 重定向)
为了将 C 语言标准库的 `printf` 输出重定向到 STM32 的串口，我们需要重写 `fputc` 函数。

**代码实现：**
```c
int fputc(int ch, FILE *stream)
{
    // 关键是下面一行代码
    // &huart1: 告诉 HAL 库使用串口1发送数据
    // (uint8_t *)&ch: 将 int 类型的 ch 强制转换为 uint8_t 指针
    // 因为原本 ch 是 32 位的，但串口一次只能发 8 位，所以取低八位发送
    HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, 10);
    return ch;
}
2. 串口输入 (中断接收原理)
原理：串口输入时，应先开启中断，形成“接收 -> 回调 -> 重新接收”的闭环。

第一步：开启中断
即“盯着”串口1输入，一旦有输入把数据放进 Rx_Buff。

C
// 启动第一次接收，每次收一个字节
HAL_UART_Receive_IT(&huart1, Rx_Buff, 1); 
第二步：编写回调函数
当中断完成后，系统会自动调用 HAL_UART_RxCpltCallback 函数。这是一个弱定义函数，我们需要在自己的代码中重写它：

C
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
    RX_Counter++;       // 接收计数增加
    Rx_tick = uwTick;   // 刷新计时器（用于判断空闲）
    
    // 【关键】：重新开启中断！
    // 因为前面的 Receive_IT 中断是一次性的，必须在这里“续费”
    // 注意这里传入的地址是 &Rx_Buff[RX_Counter]，让数据接着往后存
    HAL_UART_Receive_IT(&huart1, &Rx_Buff[RX_Counter], 1);  
}
3. 遇到的问题：数据错位
现象描述： 在进行多次发送测试时，发现接收到的数据前面会多出上次残留的字符，导致数据错位。如下图所示：

<img src="https://github.com/user-attachments/assets/bd067612-341d-449a-a024-e17aaadca2c0" width="600" />

原因分析： 虽然我们在主程序中将 RX_Counter 清零了，但 HAL 库底层的接收指针依然停留在上一次接收结束的位置（例如第 3 格）。新数据到来时，会直接填入第 3 格，导致第 0 格保留了旧数据。

4. 解决方案 (改进后的 UART_Task)
核心思路：在清零计数器之前，必须先终止 HAL 库当前正在进行的接收任务，然后从头开始重新启动接收。

❌ 改进前（有 Bug 的代码）：
C
void UART_Task()
{
    if(RX_Counter != 0)
    {
        // 简单的空闲检测（超过 5ms 没数据就认为发完了）
        if(uwTick - Rx_tick > 5)
        {
            Rx_Buff[RX_Counter] = '\0'; // 添加字符串结束符
            printf("已接受%d个数据，数据内容是 %s\r\n", RX_Counter, Rx_Buff);
            
            // 错误点：只清零了计数器，没重置 HAL 库的接收状态
            RX_Counter = 0; 
        }
    }
}
✅ 改进后（修复数据错位）：
C
void UART_Task()
{
    if(RX_Counter != 0)
    {
        if(uwTick - Rx_tick > 5)
        {
            Rx_Buff[RX_Counter] = '\0';
            printf("已接受%d个数据，数据内容是 %s\r\n", RX_Counter, Rx_Buff);

            // ---------------------------------------------------------
            // 【核心步骤】停止当前还没完成的接收任务
            // 这就好比告诉 HAL 库：“别在第 2 格傻等了，任务取消！”
            HAL_UART_AbortReceive(&huart1); 

            // 清零计数器
            RX_Counter = 0;
            
            // (可选) 清空缓冲区，防止残留
            // memset(Rx_Buff, 0, sizeof(Rx_Buff));

            // 【重启接收】明确告诉 HAL 库：一切从头开始，从第 0 格存起！
            HAL_UART_Receive_IT(&huart1, &Rx_Buff[0], 1);
            // ---------------------------------------------------------
        }
    }
}
